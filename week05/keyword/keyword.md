- **OAuth 2.0**
    <aside>
    🍠
    
    **OAuth (Open Authorization)**는 **권한 부여**를 위한 **표준 프레임워크에**요. 흔히 "로그인"이라고 부르는 **인증(Authentication)**과는 본질적으로 다르답니다.
    
    - **핵심 목표:** 사용자가 자신의 로그인 정보(비밀번호)를 제3의 서비스(클라이언트 앱)에 직접 알려주지 않으면서도, 그 서비스가 다른 서비스(리소스 서버)에 있는 사용자 **데이터에 접근할 수 있는 권한**을 안전하게 부여하도록 돕는 거예요.
    - **쉬운 예시:** "구글로 로그인" 기능을 떠올려 보세요. 우리가 만든 React 앱은 사용자님의 구글 비밀번호를 전혀 모르지만, 구글에 있는 사용자님의 프로필 정보(이름, 이메일)를 잠시 가져올 수 있는 허가증(Access Token)을 받는 거죠.
    </aside>
    
    - **OAuth 2.0**의 주요 역할자 (Roles)
        
        # **OAuth 2.0**의 주요 역할자 (Roles)
        
        **OAuth 2.0** 흐름에는 네 가지 주요 역할자가 있어요. 
        
        각자의 역할을 정확히 이해하는 것이 중요해요.
        
        ---
        
        1. **리소스 소유자 (Resource Owner):** 데이터의 주인, 즉 **사용자**예요. (예: 카카오톡 계정 소유자)
        2. **클라이언트 (Client):** 리소스 소유자 대신 데이터를 요청하려는 **우리 앱**이에요. (예: 저희가 만드는 React 웹 앱)
        3. **권한 서버 (Authorization Server):** 사용자 신원을 확인하고(인증), 클라이언트에게 접근 토큰(Access Token)을 발급하는 서버예요. (예: 네이버의 로그인/권한 부여 서버)
        4. **리소스 서버 (Resource Server):** 보호된 사용자 데이터(리소스)를 실제로 가지고 있는 서버예요. 접근 토큰을 검증해서 유효하면 데이터를 제공해요. (예: 네이버의 회원 정보 API 서버)
    - **OAuth 2.0** 인증 및 권한 부여 프로세스
        
        ### **OAuth 2.0** 인증 및 권한 부여 프로세스
        
        **OAuth 2.0**의 전형적인 흐름은 다음 단계로 진행됩니다.
        
        ---
        
        1. **사용자 인증 및 권한 부여 요청**
            
            클라이언트 애플리케이션이 **리소스 소유자**에게 특정 리소스에 접근할 수 있도록 허용할지를 요청합니다.
            
        2. **인가 코드 발급 (Authorization Code Grant)**
            
            인가 서버는 **리소스 소유자**가 동의하면 클라이언트에게 인가 코드를 발급합니다. 이 코드는 일회용이며, 액세스 토큰 요청 시 사용됩니다.
            
        3. **액세스 토큰 발급:**
            
            클라이언트는 받은 인가 코드를 인가 서버에 제출하고, 유효하다면 액세스 토큰을 발급받습니다. 이 토큰은 **리소스 서버**에 보호된 데이터를 요청할 때 사용됩니다.
            
        4. **리소스 접근:**
            
            클라이언트는 액세스 토큰을 사용해 **리소스 서버**에서 보호된 데이터를 요청합니다.
            
    - **OAuth 2.0**의 권한 부여 흐름 (Grant Types)
        
        # 권한 부여 흐름 (Grant Types)
        
        과거에는 프론트엔드에서 **Implicit Flow**를 사용했지만, 보안상의 이유로 현재는 사용을 **권장하지 않아요.** 따라서, React 앱 개발자에게 **가장 안전하고 권장되는 최신 표준**은 Authorization Code Flow with PKCE (Proof Key for Code Exchange)에요.
        
        React 앱은 `Client Secret`을 안전하게 숨길 수 없기 때문에, 이 **PKCE**라는 추가적인 검증 메커니즘을 사용해서 보안을 강화하는 거랍니다.
        
        ---
        
        ### 흐름 요약
        
        1. **PKCE 준비:** React 앱이 **`code_verifier`**(랜덤 문자열)를 생성하고, 이를 해시한 `code_challenge`를 만들어서 준비해요.
        2. **권한 요청:** React 앱이 사용자 브라우저를 **권한 서버**로 리다이렉트해요. 이때 `client_id`, `redirect_uri`, `scope`와 함께 생성한 `code_challenge`를 보냅니다.
        3. **코드 발급:** 권한 서버에서 로그인 및 동의가 완료되면, 사용자 브라우저를 우리 앱의 `redirect_uri`로 다시 리다이렉트하며 **Authorization Code**를 전달해요.
        4. **토큰 교환 (백엔드 역할):**
            - **⚠️ 중요:** React 앱(프론트엔드)은 이 코드를 직접 액세스 토큰으로 교환하면 **안 돼요.**
            - 프론트엔드에서 전달받은 **Authorization Code**와 `code_verifier`를 우리 백엔드 서버(BFF/API Gateway)가 권한 서버에 보내 Access Token 발급을 요청해요.
            - 권한 서버는 `code_verifier`를 검증하고 Access Token을 발급해서 백엔드에 전달해요.
        5. **리소스 접근:** 백엔드가 Access Token을 사용해서 리소스 서버에 접근하고 데이터를 가져와서 프론트엔드에 응답해 줍니다.
        
        ```mermaid
        sequenceDiagram
            participant U as 사용자(Resource Owner)
            participant C as React 앱(Client)
            participant AS as 권한 서버(Authorization Server)
            participant BS as 우리 백엔드(BFF/API Gateway)
            participant RS as 리소스 서버(Resource Server)
        
            U->>C: 로그인 클릭
            C->>C: code_verifier & code_challenge 생성(PKCE)
            C->>AS: (1) 리다이렉트(client_id, scope, code_challenge 등)
            AS->>U: (2) 로그인 및 권한 동의 요청
            U->>AS: (3) 로그인 및 동의
            AS->>C: (4) 리다이렉트(Authorization Code)
            C->>BS: (5) Code와 code_verifier 전달
            BS->>AS: (6) 토큰 요청(Authorization Code, code_verifier)
            AS-->>BS: (7) Access Token, Refresh Token 발급
            BS->>C: (8) HttpOnly 쿠키 등으로 로그인 세션 생성
            C->>BS: (9) 보호된 리소스 요청 (쿠키 자동 첨부)
            BS->>RS: (10) Access Token 첨부하여 리소스 요청
            RS-->>BS: (11) 리소스 응답
            BS-->>C: (12) 최종 데이터 응답
        ```
        
    - **OAuth 2.0**과 OpenID Connect
        
        ### **OAuth 2.0**과 OpenID Connect
        
        - **OAuth 2.0**
            
            주로 권한 부여에 초점을 맞추어, 리소스 접근 권한을 관리합니다.
            
        - **OpenID Connect (OIDC)**
            
            **OAuth 2.0** 위에 구축된 인증 계층으로, 사용자 인증 및 프로필 정보를 제공하여 단일 로그인을 구현할 때 사용됩니다.
            
    - **OAuth 2.0** 장점 및 단점
        
        ### **OAuth 2.0** 장점 및 단점
        
        ### 1. 장점
        
        - **보안성 강화:** 사용자의 민감한 자격 증명을 노출하지 않고, 액세스 토큰을 통한 접근 제어가 가능합니다.
        - **유연성:** 다양한 클라이언트와 인증 방식을 지원하며, 서버와 클라이언트를 분리하여 확장이 용이합니다.
        - **표준화:** 널리 사용되는 표준 프로토콜로, 다양한 플랫폼과 서비스 간에 호환성이 좋습니다.
        
        ### 2. 단점
        
        - **구현 복잡성:** 여러 가지 플로우와 구성 요소 때문에 초기 설정 및 구현이 다소 복잡할 수 있습니다.
        - **보안 취약점 가능성:** 잘못된 구현이나 설정 시 리다이렉션 URI 변조, 토큰 탈취 등의 보안 위험이 발생할 수 있습니다.
- **CORS**
  - **CORS**란 무엇인가요?
    # **CORS**란 무엇인가요?
    **CORS**는 **교차 출처 리소스 공유(Cross-Origin Resource Sharing)**의 약자예요. 이름 그대로, **다른 출처(Origin)**에 있는 자원(리소스, 즉 API 데이터)을 공유할 수 있도록 허용하는 메커니즘이죠.
    ***
    ### SOP (Same-Origin Policy) - **CORS**의 탄생 배경
    **CORS**를 이해하려면 먼저 웹 보안의 근간이 되는 **동일 출처 정책(SOP)**을 알아야 해요.
    - **SOP의 원칙:** 웹 브라우저는 기본적으로 **같은 출처**에서 온 리소스만 접근하도록 허용해요.
      - **출처(Origin) 구성 요소:** **프로토콜 (Protocol) + 도메인 (Domain) + 포트 (Port)**
    - **예시:**
      - `http://app.com:8080`과 `http://app.com:8080`은 **동일 출처**예요.
      - `https://app.com:8080`은 프로토콜이 다르므로 **다른 출처**예요. (SOP 위반)
      - `http://api.com:8080`은 도메인이 다르므로 **다른 출처**예요. (SOP 위반)
    SOP는 악의적인 웹사이트가 사용자 모르게 다른 사이트의 민감한 데이터(예: 은행 잔액, 개인 정보)를 훔쳐 가는 것을 막기 위한 방패에요.
    ***
    하지만 현대 웹 개발에서는 프론트엔드(예: `localhost:3000`)와 백엔드 API 서버(예: `api.myservice.com:8080`)가 **다른 출처**를 가질 수밖에 없죠. SOP의 엄격함을 유지하면서도 필요한 통신을 허용하기 위해 태어난 것이 바로 **CORS**랍니다.
  - **📚 블로그 읽고 Content Security Policy(CSP) 정리해보기 🍠**
    # **📚 블로그 읽고 Content Security Policy(CSP) 정리해보기 🍠**
    ***
    [개발자 매튜 | Content Security Policy(CSP)로 배우는 웹 보안 설정법](https://www.yolog.co.kr/post/http-content-security-policy)
    - 서버에서 HTML 문서를 응답할 때 CSP를 적용하려면 어떤 HTTP 응답 헤더를 설정해야 하나요? 블로그에 나온 Express.js 코드 예시를 기반으로 설명해보세요.
      ```jsx
      res.setHeader("Content-Security-Policy", "default-src 'self'");
      ```
    - `default-src 'self'` 설정은 브라우저에게 어떤 보안 정책을 의미하나요? 또한 `'self'` 값은 어떤 출처를 포함하거나 제외하나요?
      : 브라우저가 현재 문서의 출처와 같은 곳에서 온 리소스만 사용하라는 의미입니다.
    - 블로그에 나온 악성 스크립트(`<script>fetch(...)</script>`)를 주입했을 때 CSP가 어떻게 동작하는지 네트워크 탭과 콘솔 메시지 측면에서 설명해보세요.
      :브라우저가 CSP 정책을 확인하고, 인라인 스크립트를 애초에 실행하지 않습니다
    - 기본 CSP 설정에서 인라인 스타일이 차단된다고 했습니다. 블로그 예시 중 `width:600px`이 적용되지 않는 이유를 설명하세요.
      : 기본 CSP설정이 인라인 스타일도 차단합니다
    - 구글 애널리틱스, 카카오맵, 외부 API 등이 CSP 때문에 차단될 수 있다고 했습니다. 이러한 현상을 "건물 보안을 강화한다"는 비유와 연결해 설명해보세요.
      :건물 보안이 강화되서 직원들도 못들어갑니다
    - Report-Only 모드에서는 실제 리소스 실행이 차단되지 않습니다. 그 대신 브라우저와 서버에서 각각 어떤 동작을 수행하나요?
      - 브라우저: 정책 위반 진단
      - 서버: 위반한 정책 기록
    - CSP만으로는 CSRF를 막을 수 없다고 했습니다. 블로그에 정리된 다른 보안 조치들(SameSite 쿠키, X-Frame-Options 등) 중 2가지를 설명하세요.
      - SameSite 쿠키: CSRF 공격 방어
      - X-Frame-Options : iframe 랜더링금지
  - **📚 블로그 읽고 동일 출처 정책(Same Origin Policy) 정리해보기 🍠**
    # **📚 블로그 읽고 동일 출처 정책(Same Origin Policy) 정리해보기 🍠**
    ***
    [개발자 매튜 | 웹 보안의 핵심, Same Origin Policy(동일 출처 정책) 쉽게 이해하기](https://www.yolog.co.kr/post/http-same-origin-policy)
    - 출처(Origin)는 어떤 세 요소의 조합으로 결정되나요?
      1. **프로토콜** (http, https)
      2. **호스트** (도메인)
      3. **포트** (80, 443, 8080 등)
    - 출처의 요소가 다른 경우(예: 프로토콜만, 포트만 다른 경우)에 같은 출처인지 아닌지를 예시 3개(같은 출처 1개, 다른 출처 2개)로 설명하세요.
      **기준:** `https://example.com:443`
      ```jsx
      같은 출처: https://example.com:443/api/data
      → 프로토콜, 호스트, 포트 모두 동일
      다른 출처: http://example.com:443
      → http ≠ https
      다른 출처: https://example.com:8080
      → 8080 ≠ 443
      ```
    - 블로그에 나온 `fetch` 기반 악성 스크립트를 다른 출처로 실행했을 때 브라우저에서 어떤 일이 발생하나요? 네트워크 전송 여부, 응답 사용 가능성, 브라우저 콘솔 메시지 측면에서 서술하세요.
      - 네트워크 전송됨
      - 응답을 상용할 수 없음
      - cors로 인해 원격 리소스를 차단
    - SOP가 어떻게 Session Hijacking(세션 하이재킹) 시도를 방지하는지 구체적으로 설명하세요. SOP가 차단하는 것과 허용되는 것(예: 네트워크 요청은 나가지만 응답 데이터에 접근 불가)을 포함하세요.
      ### 차단
      - JavaScript의 **응답 데이터 접근**
      - 다른 출처로 데이터 전송
      - 세션 쿠키 정보 읽기
      ### **허용**
      - 네트워크 요청 전송 자체
      - 쿠키가 자동으로 요청에 포함
      - 서버가 응답 보냄
    - 블로그에서 명시한 대로 SOP가 반드시 동일 출처에서만 접근하도록 하는 주요 브라우저 API/리소스 3가지를 쓰고, 각각에 대해 간단한 설명(왜 제한되는지)을 덧붙이세요.
      - fetch: 다른 사이트 데이터 탈취 방지
      - XMLHttpRequest: 민감한 데이터에 대한 접근 방지
      - font-face: 폰트파일을 통한 데이터 유출 방지
    - SOP와 CSP의 차이를 블로그 내용에 따라 요점 4개(각 항목 1문장)로 정리하세요. (예: 누가 적용하는가, 제어 주체, 설정 가능 여부 등)
      **1. 적용 주체**
      - **SOP**: 브라우저가 자체적으로 적용
      - **CSP**: 서버에서 정책 설정, 브라우저가 실행
      **2. 개발자 제어**
      - **SOP**: 자동 적용, 개발자가 직접 제어 불가
      - **CSP**: 개발자가 HTTP 헤더로 직접 설정
      **3. 설정 범위**
      - **SOP**: 모든 웹페이지에 기본 적용, 브라우저별 구현 차이
      - **CSP**: 애플리케이션별 맞춤 설정, Report-Only로 단계적 적용 가능
      **4. 보안 목적**
      - **SOP**: 다른 출처 자원 접근 차단
      - **CSP**: XSS 공격 방지, 악성 스크립트 실행 차단
    - 브라우저에서 SOP 관련 차단 오류를 발견했을 때(예: 콘솔에 “동일 출처 정책으로 인해 ... 차단했습니다” 메시지) 문제 원인 파악을 위한 체크리스트(최소 3항목)를 작성하고, 임시·영구 대응 방안(각 1~2줄)도 제시하세요.
      출처, 네트워크 탭, 리소스 종류
      - 백엔드 CORS 설정
      - 프록시 설정
  - **CORS** 작동 방식: 요청의 종류
    ## **CORS** 작동 방식: 요청의 종류
    **CORS** 요청은 브라우저가 보안 검사를 진행하는 방식에 따라 크게 두 가지로 나뉘어요.
    ***
    ### 1. Simple Request (단순 요청)
    다음 **세 가지 조건**을 **모두** 만족하는 요청이에요. 브라우저는 서버에 요청을 보낸 후, 서버의 응답 헤더를 보고 접근 허용 여부를 판단해요.
    | 조건             | 세부 내용                                                                                  |
    | ---------------- | ------------------------------------------------------------------------------------------ |
    | **메소드**       | `GET`, `POST`, `HEAD` 중 하나여야 해요.                                                    |
    | **허용 헤더**    | `Accept`, `Accept-Language`, `Content-Language`, `Content-Type` 중 하나여야 해요.          |
    | **Content-Type** | `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain` 중 하나여야 해요. |
    **✅ 흐름:** **요청 전송 → 응답 수신 → 브라우저가 CORS 헤더 확인 → 통과 시 데이터 전달**
    ***
    ### 2. Preflight Request (프리플라이트 요청)
    Simple Request 조건을 하나라도 만족하지 못하는 요청(예: `PUT`, `DELETE` 메소드, `Content-Type: application/json` 사용, 사용자 정의 헤더 사용 등)에 대해 브라우저가 사용하는 방식이에요.
    **⚠️ 이 방식이 중요해요!**
    브라우저는 본 요청을 보내기 전에 서버에게 "내가 이런 요청을 보내도 될까요?" 하고 미리 물어보는 예비 요청을 보내요.
    - **메소드:** `OPTIONS`
    - **목적:** 서버가 실제 요청을 받아들일 준비가 되어 있는지, 어떤 메소드와 헤더를 허용하는지 미리 확인해요.
    **✅ 흐름:** **`OPTIONS` 요청 전송 → 서버가 허용 헤더로 응답 → 브라우저가 통과 확인 → 본 요청 전송**
    > 팁: React에서 fetch나 axios로 PUT, DELETE, 또는 Content-Type: application/json을 사용하는 POST 요청을 보내면, 무조건 Preflight Request가 발생하게 된답니다. 브라우저 개발자 도구의 Network 탭에서 OPTIONS 요청을 확인해 보세요.
  - **CORS** 해결책
    ## **CORS** 해결책
    **CORS** 에러는 클라이언트(브라우저)가 띄우지만, 사실상 이 문제를 해결할 책임은 **서버(백엔드)** 측에 있어요.
    프론트엔드 개발자로서 이 에러를 마주했을 때 취해야 할 조치와 원칙을 정리해 드릴게요.
    ***
    ### 1. 서버 개발팀에 요청할 헤더 설정
    **CORS** 문제를 해결하는 핵심은 **서버가 응답 헤더에 명시적으로 클라이언트의 접근을 허용**하는 정보를 담아주는 거예요.
    | 헤더                                   | 역할                                                                                               | 예시 값                                                          |
    | -------------------------------------- | -------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
    | **`Access-Control-Allow-Origin`**      | **필수!** 이 출처의 접근을 허용해요.                                                               | `http://localhost:3000` 또는 `*` (모든 출처 허용, 권장되지 않음) |
    | **`Access-Control-Allow-Methods`**     | 허용할 HTTP 메소드를 정의해요. (Preflight 응답용)                                                  | `GET, POST, PUT, DELETE`                                         |
    | **`Access-Control-Allow-Headers`**     | 허용할 요청 헤더를 정의해요. (Preflight 응답용, 특히 `Authorization` 헤더는 필수로 추가해야 해요.) | `Content-Type, Authorization`                                    |
    | **`Access-Control-Allow-Credentials`** | `true`로 설정 시, 쿠키나 인증 정보(`Authorization` 헤더)를 요청에 포함할 수 있도록 허용해요.       | `true`                                                           |
    ***
    ### 2. React 환경에서 임시 해결책: Proxy 설정
    개발 환경에서 백엔드 서버가 아직 **CORS** 설정을 완료하지 않았거나, 포트를 맞춰주기 어려울 때 React 앱에서 임시방편으로 사용할 수 있는 방법이에요.
    ***
    - **원리:** 브라우저의 SOP는 클라이언트 서버(React)에 대한 요청만 확인해요. React 앱에서 API 요청을 보낼 때, 실제 API 주소 대신 **자신의 도메인**으로 요청하고, React 개발 서버(webpack/Vite)가 이 요청을 받아서 **실제 API 서버로 대신 전달**해 주는 방식이에요. 이 과정은 서버 간의 통신이므로 SOP/**CORS**가 적용되지 않아요.
    - Create React App (CRA)의 경우:JSON
      package.json 파일에 간단하게 proxy 속성을 추가해요.
      `"proxy": "http://api.myservice.com:8080"`
      이제 React 코드에서 `fetch('/api/data')`를 호출하면, 개발 서버가 `http://api.myservice.com:8080/api/data`로 대신 요청을 보내줘요.
    ***
    ### 3. 인증 정보 전달 시 유의사항
    토큰 기반 인증(OAuth 2.0)이나 세션/쿠키를 사용할 때 **CORS**와 관련된 중요한 사항이에요.
    1. **쿠키 사용 시:** `HttpOnly` 쿠키를 사용한다면, 요청 시 `credentials: 'include'` 옵션(또는 `withCredentials: true`)을 설정하고, 서버는 반드시 \**`Access-Control-Allow-Credentials: true`*를 응답해야 해요.
    2. **`Authorization` 헤더:** JWT 등의 토큰을 `Authorization` 헤더에 담아 보낸다면, 서버의 Preflight 응답에 **`Access-Control-Allow-Headers`** 목록에 `Authorization`이 반드시 포함되어야 한답니다.
    **CORS**는 웹 개발의 뗄 수 없는 그림자 같은 존재예요.
    에러를 마주했을 때 당황하지 말고, **"아, 이건 백엔드의 헤더 설정 문제구나"**라고 판단하고 위에 정리된 헤더 목록을 전달하며 소통하는 개발자의 모습을 보여주세요!
  - **📚 블로그 읽고 교차 출처 리소스 공유(CORS) 정리해보기 🍠**
    # **📚 블로그 읽고 교차 출처 리소스 공유(CORS) 정리해보기 🍠**
    ***
    [개발자 매튜 | 악명 높은 CORS(교차 출처 리소스 공유) 쉽게 이해하기](https://www.yolog.co.kr/post/http-cors)
    - 브라우저에서 `http://localhost:8080` 애플리케이션이 `http://localhost:8081/resource.json`을 요청했을 때, 네트워크 요청과 응답은 어떻게 처리되며, 브라우저가 응답 본문을 사용하지 못하는 이유는 무엇인가요?
      1. 응답 헤더 중 **`Access-Control-Allow-Origin`**을 확인한다
      2. 이 헤더에 **현재 출처가 포함되어 있는지** 검사한다
      3. 서버가 해당 출처를 **허용했는지** 판단한다
      : 출처가 다름
    - 서버가 다른 출처(`http://localhost:8080`)에서 자원을 사용할 수 있게 하려면 어떤 응답 헤더를 어떻게 설정해야 하나요? 글의 예시 코드를 참고해 헤더 이름과 값까지 구체적으로 쓰세요.
      ```jsx
      const handler = (req, res) => {
        // localhost:8080 출처를 허용
        res.setHeader("Access-Control-Allow-Origin", "http://localhost:8080");
        static(path.join(__dirname, "public"))(req, res);
      };
      ```
    - 단순 요청으로 분류되기 위해서는 어떤 두 가지 조건을 만족해야 하나요? 또한 `GET /resource.json` 요청이 단순 요청에 해당하는 이유를 설명하세요.
      : 허용된 요청과 헤더여서
    - 브라우저에서 `X-Goguma`라는 커스텀 헤더를 추가했을 때 왜 차단이 발생하나요? 이 문제를 해결하기 위해 서버에서 추가해야 하는 응답 헤더와 값은 무엇인가요?
      : X-Goguma는 허용된 헤더가 아니어서
      → Preflight 요청 발생
    - `PUT` 요청을 보낼 때 브라우저는 왜 먼저 `OPTIONS` 요청을 보내나요? 이때 브라우저가 보내는 헤더와 서버가 응답해야 하는 헤더를 각각 쓰고, 사전 요청과 실제 요청이 어떻게 이어지는지 간단히 서술하세요.
      :PUT은 단순 요청 허용 메서드가 아니여서
      ```jsx
      Access-Control-Request-Method: PUT
      ```
      ```jsx
      Access-Control-Allow-Methods: PUT
      ```
- **RBAC vs ABAC**
    <aside>
    🍠
    
    **RBAC과 ABAC은 모두 '누가', '무엇을' 할 수 있는지 결정하는 접근 제어(Access Control) 모델이에요.**
    
    시스템과 데이터의 문을 관리하는 두 가지 방식이라고 생각하면 쉬워요. **RBAC은 신분증(역할)**을 보고, **ABAC은 다양한 조건(속성)**을 보고 문을 열어줄지 말지 판단한답니다.
    
    </aside>
    
    - **RBAC (Role-Based Access Control) : 역할 기반 접근 제어**
        
        ## **RBAC** (Role-Based Access Control) : 역할 기반 접근 제어
        
        **RBAC은 사용자의 '역할(Role)'을 기준으로 권한을 할당하는 방식이에요.** 가장 흔하게 사용되며, 관리하기 쉽다는 장점이 있어요.
        
        ---
        
        ### 🔑 핵심 개념
        
        | 용어 | 설명 | 예시 |
        | --- | --- | --- |
        | **사용자 (User)** | 시스템을 이용하는 사람이나 계정이에요. | 개발팀 김철수 사원 |
        | **역할 (Role)** | 수행하는 직무나 기능에 따라 **권한들을 묶어 놓은** 집합이에요. | '재무팀 관리자', '일반 사용자', '서버 엔지니어' |
        | **권한 (Permission)** | 리소스에 대해 구체적으로 할 수 있는 작업이에요. | `파일 읽기`, `사용자 추가`, `결제 승인` |
        
        ---
        
        ### 🧐 작동 방식
        
        1. **권한을 역할에 할당해요.** (예: '재무팀 관리자' 역할에는 `결제 승인` 권한을 할당해요.)
        2. **사용자에게 역할을 부여해요.** (예: 김철수 사원에게 '재무팀 관리자' 역할을 할당해요.)
        3. **결과:** 김철수 사원은 '재무팀 관리자' 역할에 있는 모든 권한, 즉 `결제 승인` 권한을 자동으로 갖게 된답니다.
        
        ---
        
        ### 👍 장점과 특징
        
        - **관리 효율성:** 수백 명의 사용자에게 일일이 권한을 부여할 필요 없이 역할만 할당하면 돼서 관리가 매우 편리하고 확장성이 좋아요.
        - **단순함:** 구조가 명확해서 대부분의 조직 환경에 적용하기 쉬워요.
        - **정적(Static) 모델:** 역할이 한 번 정의되면 잘 바뀌지 않는 비교적 고정적인 방식이에요.
        
    - **ABAC (Attribute-Based Access Control) : 속성 기반 접근 제어**
        
        ## **ABAC** (Attribute-Based Access Control) : 속성 기반 접근 제어
        
        **ABAC은 '속성(Attribute)'과 '조건'을 기반으로 권한을 동적으로 결정하는 방식이에요.** **RBAC**보다 훨씬 더 세밀하고 유연한 통제가 필요할 때 사용해요.
        
        ---
        
        ### 🔑 핵심 개념
        
        ABAC에서는 접근 요청을 승인할지 거부할지 판단하기 위해 **네 가지 유형의 속성**을 활용해요.
        
        | 속성 유형 | 설명 | 예시 |
        | --- | --- | --- |
        | **주체(사용자) 속성** | 접근을 요청하는 사용자의 특성이에요. | 부서: `마케팅팀`, 직위: `팀장`, 보안등급: `1등급` |
        | **객체(리소스) 속성** | 접근하려는 대상(파일, 데이터)의 특성이에요. | 민감도: `극비`, 파일 소유자: `John`, 위치: `US-East 서버` |
        | **작업 속성** | 사용자가 하려는 행동이에요. | `읽기(Read)`, `쓰기(Write)`, `다운로드(Download)` |
        | **환경 속성** | 접근이 요청되는 외부 상황(컨텍스트)이에요. | 시간: `업무 시간(09:00~18:00)`, 네트워크: `내부망`, 장치: `회사 지급 노트북` |
        
        ---
        
        ### 🧐 작동 방식
        
        1. **정책(Policy)을 정의해요.** 이 정책은 속성들을 조합한 **'만약/그러면'** 형태의 규칙이에요.
        2. **정책 예시:** **"만약** 사용자 속성(부서=재무팀)이고 **그리고** 리소스 속성(민감도=높음)이면, **그리고** 환경 속성(시간=업무 시간)일 **때만**, **그러면** 작업 속성(읽기)을 **허용한다.**"
        3. **결과:** 실시간으로 접근 요청이 들어올 때마다 이 정책을 평가해서 그때그때 권한을 부여할지 말지 **동적으로** 결정해요.
        
        ---
        
        ### 👍 장점과 특징
        
        - **세분화된 제어:** '재무팀의 김철수 사원이 평일 오전 9시에서 오후 6시 사이에만 극비 파일을 읽을 수 있다'와 같이 매우 정교한 제어가 가능해요.
        - **동적(Dynamic) 모델:** 상황(시간, 위치)이 바뀌면 실시간으로 접근 권한도 바뀔 수 있어요.
        - **유연성:** 새로운 리소스나 사용자 역할이 추가되어도 정책의 속성만 잘 정의하면 기존 정책을 그대로 활용할 수 있어요.
    - **RBAC vs ABAC 한눈에 비교하기**
        
        ## 한눈에 비교하기
        
        ---
        
        | 구분 | **RBAC** (역할 기반) | ABAC (속성 기반) |
        | --- | --- | --- |
        | **핵심 요소** | 역할 (Role) | 속성 (Attribute) 및 정책 (Policy) |
        | **접근 결정** | **할당된 역할**만 보고 결정해요. | **다양한 속성**과 **조건**을 모두 따져 동적으로 결정해요. |
        | **유연성** | 상대적으로 낮아요. | 상대적으로 매우 높아요. |
        | **복잡성** | 단순하고 관리하기 쉬워요. | 정책 정의와 관리가 복잡할 수 있어요. |
        | **언제 쓸까요?** | 권한 구조가 고정적이고 명확한 **일반 기업 시스템**에 적합해요. | **클라우드 환경**이나 **매우 민감한 데이터** 제어와 같이 세밀하고 동적인 제어가 필요할 때 적합해요. |
    - **📚 블로그 읽고 ABAC 정리해보기 🍠**
        
        # **📚 블로그 읽고 ABAC 정리해보기 🍠**
        
        ---
        
        <aside>
        🍠
        
        해당 블로그 포스트는 제가 실제로 사내에서 겪은 문제점을 쉽게 해결하기 위해 고민한 내용을 담은 글입니다!
        
        여러분들이라면, 어떠한 상황일 때 의사결정을 내릴지 여러분의 입장에서 정리를 해보시면 좋을 것 같습니다!
        
        늘 그렇지만 블로그를 읽고 답변하는 부분에는 명확한 정답이 없으니 정말 편하게 고민하는 시간을 갖어보셨으면 합니다!
        
        - UMC 중앙 웹 파트장 매튜/김용민 -
        
        </aside>
        
        [개발자 매튜 | 복잡한 권한, 깔끔하게 관리하기 - ABAC 도입기](https://www.yolog.co.kr/post/rbac-abac)
        
        - **RBAC**의 한계에 대해 설명해주세요.
            
            : 유연성과 확장성이 낮
            
        - **ABAC**으로의 전환, 어떤 '기준'이 적절할까요?
            
            :같은 역할인데 권한이 다른 경우 || 확장성이 고려되어야 하는 경우
            
        - 어떤 서비스 영역에 **RBAC**을 남겨두고, **ABAC**을 도입하시겠어요?
            - RBAC: 명확한 권한
            - ABAC: 복잡
        - 여러분들은 다른 부서에서 요청을 받았을 때 어떤식으로 행동하실껀가요?
